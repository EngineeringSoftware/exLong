[
    {
        "methodStrings": [
            "public static Match match(JsonElement root, Path path) throws SubdocException {\n        Match m = new Match(root, path);\n        m.execute();\n        return m;\n    }",
            "public void execute() throws SubdocException {\n        JsonElement parent = root;\n\n        for (int i = 0; i < path.size(); i++) {\n            path.validateComponentType(i, parent);\n            Component component = path.get(i);\n\n            if (component.isIndex()) {\n                int index = component.getIndex();\n                JsonArray array = parent.getAsJsonArray();\n                if (array.size() == 0) {\n                    // Empty array\n                    break;\n                }\n\n                if (index == -1) {\n                    index = array.size() - 1;\n                } else if (index > array.size() - 1) {\n                    break; // Not found!\n                }\n                parent = array.get(index);\n            } else {\n                JsonObject object = parent.getAsJsonObject();\n                parent = object.get(component.getString());\n            }\n\n            if (parent == null) {\n                // Match not found here!\n                break;\n            }\n\n            chain.add(parent);\n        }\n    }",
            "public void validateComponentType(int ix, JsonElement parent) throws PathMismatchException, PathParseException {\n        Component comp = components.get(ix);\n        if (parent.isJsonPrimitive() || parent.isJsonNull())\n            throw new PathMismatchException();\n\n        if (comp.isIndex())\n\n        {\n            if (!parent.isJsonArray()) {\n                throw new PathParseException(\"Object operation cannot have an array index as its last component\");\n            }\n        } else {\n            if (!parent.isJsonObject()) {\n                throw new PathMismatchException();\n            }\n        }\n    }"
        ],
        "lineNumbers": [
            4,
            6,
            15
        ]
    },
    {
        "methodStrings": [
            "static public Number getElementAt(Matrix matrix, int row, int column){\n List<Array> arrays = matrix.getArrays();\n List<MatCell> matCells = matrix.getMatCells();\n\n Matrix.Kind kind = matrix.getKind();\n switch(kind){\n  case DIAGONAL:\n  {\n   // \"The content is just one Array of numbers representing the diagonal values\"\n   if(arrays.size() == 1){\n   Array array = arrays.get(0);\n\n   List<? extends Number> elements = ArrayUtil.asNumberList(array);\n\n   // Diagonal element\n   if(row == column){\n    return elements.get(row - 1);\n   } else\n\n   // Off-diagonal element\n   {\n    int min = 1;\n    int max = elements.size();\n\n    if((row < min || row > max) || (column < min || column > max)){\n    throw new IndexOutOfBoundsException();\n    }\n\n    return matrix.getOffDiagDefault();\n   }\n   }\n  }\n  break;\n  case SYMMETRIC:\n  {\n   // \"The content must be represented by Arrays\"\n   if(!arrays.isEmpty()){\n\n   // Make sure the specified coordinates target the lower left triangle\n   if(column > row){\n    int temp = row;\n\n    row = column;\n    column = temp;\n   }\n\n    return getArrayValue(arrays, row, column);\n   }\n  }\n  break;\n  case ANY:\n  {\n   if(!arrays.isEmpty()){\n   return getArrayValue(arrays, row, column);\n   } // End if\n\n   if(!matCells.isEmpty()){\n\n   if(row < 1 || column < 1){\n    throw new IndexOutOfBoundsException();\n   }\n\n   Number value = getMatCellValue(matCells, row, column);\n   if(value == null){\n\n    if(row == column){\n    return matrix.getDiagDefault();\n    }\n\n    return matrix.getOffDiagDefault();\n   }\n\n   return value;\n   }\n  }\n  break;\n  default:\n  throw new UnsupportedAttributeException(matrix, kind);\n }\n\n throw new InvalidElementException(matrix);\n }",
            "static private Number getArrayValue(List<Array> arrays, int row, int column){\n Array array = arrays.get(row - 1);\n\n List<? extends Number> elements = ArrayUtil.asNumberList(array);\n\n return elements.get(column - 1);\n}"
        ],
        "lineNumbers": [
            48,
            3
        ]
    },
    {
        "methodStrings": [
            "static public FieldValue evaluate(Expression expression, EvaluationContext context){\n\n    try {\n                return evaluateExpression(expression, context);\n    } catch(PMMLException pe){\n        throw pe.ensureContext(expression);\n    }\n}",
            "static FieldValue evaluateExpression(Expression expression, EvaluationContext context){\n\n        if(expression instanceof Constant){\n            return evaluateConstant((Constant)expression);\n        } else\n\n        if(expression instanceof FieldRef){\n            return evaluateFieldRef((FieldRef)expression, context);\n        } else\n\n        if(expression instanceof NormContinuous){\n            return evaluateNormContinuous((NormContinuous)expression, context);\n        } else\n\n        if(expression instanceof NormDiscrete){\n            return evaluateNormDiscrete((NormDiscrete)expression, context);\n        } else\n\n        if(expression instanceof Discretize){\n            return evaluateDiscretize((Discretize)expression, context);\n        } else\n\n        if(expression instanceof MapValues){\n            return evaluateMapValues((MapValues)expression, context);\n        } else\n\n        if(expression instanceof TextIndex){\n            return evaluateTextIndex((TextIndex)expression, context);\n        } else\n\n        if(expression instanceof Apply){\n             return evaluateApply((Apply)expression, context);\n        } else\n\n        if(expression instanceof Aggregate){\n            return evaluateAggregate((Aggregate)expression, context);\n        } // End if\n\n        if(expression instanceof JavaExpression){\n            return evaluateJavaExpression((JavaExpression)expression, context);\n        }\n\n        throw new UnsupportedElementException(expression);\n    }",
            "static public FieldValue evaluateApply(Apply apply, EvaluationContext context){\n        String mapMissingTo = apply.getMapMissingTo();\n\n        String function = apply.requireFunction();\n        List<Expression> expressions = apply.getExpressions();\n\n        List<FieldValue> values = new ArrayList<>(expressions.size());\n\n        int max = expressions.size();\n\n        if((PMMLFunctions.IF).equals(function)){\n\n            if(max > 0){\n                FieldValue flag = evaluate(expressions.get(0), context);\n\n                if(flag == null && mapMissingTo != null){\n                    return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, mapMissingTo);\n                }\n\n                values.add(flag);\n\n                // Skip both THEN and ELSE parts\n                if(flag == null){\n\n                    if(max > 1){\n                        values.add(FieldValues.MISSING_VALUE);\n\n                        if(max > 2){\n                            values.add(FieldValues.MISSING_VALUE);\n                        }\n                    }\n                } else\n\n                // Evaluate THEN part, skip ELSE part\n                if(flag.asBoolean()){\n\n                    if(max > 1){\n                        FieldValue trueValue = evaluate(expressions.get(1), context);\n\n                        if(FieldValueUtil.isMissing(trueValue) && mapMissingTo != null){\n                            return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, mapMissingTo);\n                        }\n\n                        values.add(trueValue);\n\n                        if(max > 2){\n                            values.add(FieldValues.MISSING_VALUE);\n                        }\n                    }\n                } else\n\n                // Skip THEN part, evaluate ELSE part\n                {\n                    if(max > 1){\n                        values.add(FieldValues.MISSING_VALUE);\n\n                        if(max > 2){\n                            FieldValue falseValue = evaluate(expressions.get(2), context);\n\n                            if(FieldValueUtil.isMissing(falseValue) && mapMissingTo != null){\n                                return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, mapMissingTo);\n                            }\n\n                            values.add(falseValue);\n                        }\n                    }\n                }\n            }\n        }\n\n        for(int i = values.size(); i < max; i++){\n            Expression expression = expressions.get(i);\n\n            FieldValue value = evaluate(expression, context);\n\n            // \"If a mapMissingTo value is specified and any of the input values of the function are missing, then the function is not applied at all and the mapMissingTo value is returned instead\"\n            if(FieldValueUtil.isMissing(value) && mapMissingTo != null){\n                return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, mapMissingTo);\n            }\n\n            values.add(value);\n        }\n\n        String defaultValue = apply.getDefaultValue();\n\n        FieldValue result;\n\n        SymbolTable<String> symbolTable = EvaluationContext.FUNCTION_GUARD_PROVIDER.get();\n\n        if(symbolTable != null){\n            symbolTable.lock(function);\n        }\n\n        try {\n            result = evaluateFunction(function, values, context);\n        } catch(InvalidResultException ire){\n            InvalidValueTreatmentMethod invalidValueTreatmentMethod = apply.getInvalidValueTreatment();\n\n            switch(invalidValueTreatmentMethod){\n                case RETURN_INVALID:\n                     throw new EvaluationException(\"Function \" + EvaluationException.formatName(function) + \" returned invalid value\", apply)\n                        .initCause(ire);\n                case AS_IS:\n                    // Re-throw the given InvalidResultException instance\n                    throw ire;\n                case AS_MISSING:\n                    return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, defaultValue);\n                case AS_VALUE:\n                    throw new InvalidAttributeException(apply, invalidValueTreatmentMethod);\n                default:\n                    throw new UnsupportedAttributeException(apply, invalidValueTreatmentMethod);\n            }\n        } finally {\n\n            if(symbolTable != null){\n                symbolTable.release(function);\n            }\n        }\n\n        // \"If a defaultValue value is specified and the function produced a missing value, then the defaultValue is returned\"\n        if(FieldValueUtil.isMissing(result) && defaultValue != null){\n            return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, defaultValue);\n        }\n\n        return result;\n    }"
        ],
        "lineNumbers": [
            5,
            33,
            110
        ]
    },
    {
        "methodStrings": [
            "protected ReflectedFormatter()\n    {\n        Names namesAnnotation = getClass().getAnnotation(Names.class);\n        if (namesAnnotation == null)\n        {\n            throw new AnnotationMissingException(Names.class);\n        }\n        this.names = new HashSet<String>(asList(namesAnnotation.value()));\n         this.formats = findFormatMethods();\n        if (this.formats.isEmpty())\n        {\n            throw new AnnotationMissingException(Format.class);\n        }\n    }",
            "private Map<Class<?>, Formatter> findFormatMethods()\n    {\n        final Map<Class<?>, Formatter> formats = new HashMap<Class<?>, Formatter>();\n        for (Method method : this.getClass().getMethods())\n        {\n            Format formatAnnotation = method.getAnnotation(Format.class);\n            if (formatAnnotation != null)\n            {\n                Class<?>[] parameterTypes = method.getParameterTypes();\n                if (parameterTypes.length == 0)\n                {\n                    throw new InvalidFormatMethodException(getClass(), method, \"Format methods must take at least 1 parameter!\");\n                }\n                formats.put(parameterTypes[0], createFormatter(method, parameterTypes, formatAnnotation.value()));\n            }\n        }\n        return formats;\n    }",
            "private Formatter createFormatter(Method method, Class<?>[] sig, int prio)\n    {\n        if (method.getReturnType() != Component.class)\n        {\n            throw new InvalidFormatMethodException(getClass(), method, \"Format methods must return Component!\");\n        }\n\n        final Invoker invoker;\n        if (sig.length == 1)\n        {\n            invoker = new InputOnly();\n        }\n        else if (sig.length == 2)\n        {\n            if (sig[1] == Context.class)\n            {\n                invoker = new ContextOnly();\n            }\n            else if (sig[1] == Arguments.class)\n            {\n                invoker = new ArgsOnly();\n            }\n            else\n            {\n                throw new InvalidFormatMethodException(getClass(), method,\n                                                       \"Format methods may only take Context and Arguments parameters!\");\n            }\n        }\n        else if (sig.length == 3)\n        {\n            if (sig[1] == Context.class && sig[2] == Arguments.class)\n            {\n                invoker = new CompleteContextFirst();\n            }\n            else if (sig[1] == Arguments.class && sig[2] == Context.class)\n            {\n                invoker = new CompleteArgsFirst();\n            }\n            else\n            {\n                throw new InvalidFormatMethodException(getClass(), method,\n                                                       \"Format methods may only take Context and Arguments parameters!\");\n            }\n        }\n        else\n        {\n            throw new InvalidFormatMethodException(getClass(), method,\n                                                   \"Format methods must take at most 3 parameters!\");\n        }\n        return new Formatter(this, method, prio, invoker);\n    }\n"
        ],
        "lineNumbers": [
            10,
            15,
            6
        ]
    },
    {
        "methodStrings": [
            "@Overridea\n    public SqlQuerySpec generateCosmos(DocumentQuery query) {\n        return super.generateCosmosQuery(query, \"SELECT * FROM ROOT r\");\n    }",
            "protected SqlQuerySpec generateCosmosQuery(@NonNull DocumentQuery query,\n                                                                            @NonNull String queryHead) {\n         final Pair<String, List<Pair<String, Object>>> queryBody = generateQueryBody(query);\n        final String queryString = String.join(\" \", queryHead, queryBody.getValue0(), generateQueryTail(query));\n        final List<Pair<String, Object>> parameters = queryBody.getValue1();\n        final SqlParameterList sqlParameters =\n                new SqlParameterList();\n\n        sqlParameters.addAll(\n                parameters.stream()\n                        .map(p -> new com.azure.data.cosmos.SqlParameter(\"@\" + p.getValue0(),\n                                toCosmosDbValue(p.getValue1())))\n                        .collect(Collectors.toList())\n        );\n\n        return new SqlQuerySpec(queryString, sqlParameters);\n    }",
            "@NonNull\n    private Pair<String, List<Pair<String, Object>>> generateQueryBody(@NonNull DocumentQuery query) {\n        final List<Pair<String, Object>> parameters = new ArrayList<>();\n        String queryString = this.generateQueryBody(query.getCriteria(), parameters);\n\n        if (StringUtils.hasText(queryString)) {\n            queryString = String.join(\" \", \"WHERE\", queryString);\n        }\n\n        return Pair.with(queryString, parameters);\n    }",
            "private String generateQueryBody(@NonNull Criteria criteria, @NonNull List<Pair<String, Object>> parameters) {\n    final CriteriaType type = criteria.getType();\n\n    switch (type) {\n        case ALL:\n            return \"\";\n        case IN:\n        case NOT_IN:\n                 return generateInQuery(criteria);\n        case BETWEEN:\n            return generateBetween(criteria, parameters);\n        case IS_NULL:\n        case IS_NOT_NULL:\n        case FALSE:\n        case TRUE:\n            return generateUnaryQuery(criteria);\n        case IS_EQUAL:\n        case NOT:\n        case BEFORE:\n        case AFTER:\n        case LESS_THAN:\n        case LESS_THAN_EQUAL:\n        case GREATER_THAN:\n        case GREATER_THAN_EQUAL:\n        case CONTAINING:\n        case ENDS_WITH:\n        case STARTS_WITH:\n            return generateBinaryQuery(criteria, parameters);\n        case AND:\n        case OR:\n            Assert.isTrue(criteria.getSubCriteria().size() == 2, \"criteria should have two SubCriteria\");\n\n            final String left = generateQueryBody(criteria.getSubCriteria().get(0), parameters);\n            final String right = generateQueryBody(criteria.getSubCriteria().get(1), parameters);\n\n            return generateClosedQuery(left, right, type);\n        default:\n            throw new UnsupportedOperationException(\"unsupported Criteria type: \" + type);\n    }\n}\n",
            "@SuppressWarnings(\"unchecked\")\n    private String generateInQuery(Criteria criteria) {\n        Assert.isTrue(criteria.getSubjectValues().size() == 1, \"Criteria should have only one subject value\");\n        if (!(criteria.getSubjectValues().get(0) instanceof Collection)) {\n            throw new IllegalQueryException(\"IN keyword requires Collection type in parameters\");\n        }\n        final List<String> inRangeValues = new ArrayList<>();\n        final Collection values = (Collection) criteria.getSubjectValues().get(0);\n\n        values.forEach(o -> {\n            if (o instanceof Integer || o instanceof Long) {\n                inRangeValues.add(String.format(\"%d\", o));\n            } else if (o instanceof String) {\n                inRangeValues.add(String.format(\"'%s'\", (String) o));\n            } else if (o instanceof Boolean) {\n                inRangeValues.add(String.format(\"%b\", (Boolean) o));\n            } else {\n                throw new IllegalQueryException(\"IN keyword Range only support Number and String type.\");\n            }\n        });\n\n        final String inRange = String.join(\",\", inRangeValues);\n        return String.format(\"r.%s %s (%s)\", criteria.getSubject(), criteria.getType().getSqlKeyword(), inRange);\n    }"
        ],
        "lineNumbers": [
            4,
            4,
            5,
            10,
            17
        ]
    }
]